using Namespace System.IO
using Namespace System.Management.Automation
using Namespace System.Collections.Generic
<#  
    This is an AD Config module for use with DryDeploy, or by itself.
    Copyright (C) 2021  Bjørn Henrik Formo (bjornhenrikformo@gmail.com)
    LICENSE: https://raw.githubusercontent.com/bjoernf73/dry.module.ad/main/LICENSE

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#>
function Import-DryADConfiguration {
    [CmdLetBinding(DefaultParameterSetName = 'Local')]
    param (
        [Parameter(HelpMessage = "Variables are used for replacements in configs and GPOs")]
        [List[PSObject]] 
        $Variables,

        [Parameter(HelpMessage = "Path to a json containing an array of objects resolving replacement patterns in your configuration. The objects must contain the properties 'name' and 'value'")]
        [ValidateScript({ { Resolve-Path -Path $_ } })]
        [FileInfo] 
        $VariablesPath,

        [Parameter(Mandatory, HelpMessage = "Path of the configuration directory")]
        [ValidateScript({ Resolve-Path -Path $_ })]
        [DirectoryInfo] 
        $ConfigurationPath,

        [Parameter(HelpMessage = "Shortname (not IP!) of the computer for which the configuration is run")]
        [String] 
        $ComputerName,

        [Parameter(HelpMessage = "Active Directory site name for which the configuration is done")]
        [String] 
        $ADSite,

        [Parameter(HelpMessage = "Array of one or more Types to process. By default, all are processed")]
        [ValidateSet('ou_schema', 'rights_groups', 'role_groups', 'group_members', 'rights', 'gpo_imports', 'gpo_links',
            'wmi_filters', 'wmi_filters_links', 'ad_schema', 'netlogon', 'adm_templates', 'users', 'users_memberof')] 
        [String[]] 
        $Types,

        [Parameter(HelpMessage = "NOT IMPLEMENTED YET. Objects may be defined with an array of tags to group them logically. 
        The Tags parameter allows you to filter on objects, so only objects that have a tag defined corresponding to an 
        element in `$Tags, are processed. If `$Tags is `$null, Tags are ignored")]
        [String[]] 
        $Tags,

        [Parameter(Mandatory, ParameterSetName = 'Local', HelpMessage = "Specify a resolvable name or IP to a Domain Controller to perform AD actions on")]
        [String] 
        $DomainController,

        [Parameter(Mandatory, ParameterSetName = 'Remote')]
        [PSSession] 
        $PSSession,

        [Parameter(HelpMessage = "Should only be `$True when called from DryDeploy. Will allow autogenerated 
        passwords for users that are created to be stored in DryDeploy's Credentials store. If you're running
        standalone (not as part of DryDeploy, hence `$DryDeploy = `$False), then passwords of users that are 
        configured with the property .password.get_or_generate = 'generate', are autogenerated, but lost. You 
        will have to reset the passwords of the created users to access those accounts. Use instead
        .password.get_or_generate = 'get' to be prompted for the credentials.")]
        [Switch]$DryDeploy
    )
    try {
        ol i 'Import-DryADConfiguration started' -sh
        
        If ($DebugPreference) { 
            If ($DebugPreference -eq 'Inquire') {
                $DebugPreference = 'Continue'
            }
        }

        [String]$ExecutionType = $PSCmdlet.ParameterSetName
        ol i 'Execution Type', "$ExecutionType"

        $ConfigurationPath = (Resolve-Path -Path $ConfigurationPath -ErrorAction Stop).Path
        ol i 'ConfigurationPath', "$ConfigurationPath"

        If ($VariablesPath) {
            $VariablesPath = (Resolve-Path -Path $VariablesPath -ErrorAction Stop).Path
            ol i 'VariablesPath', "$VariablesPath"
        }
        
        if ($ExecutionType -eq 'Remote') {
            $ConfigurationPublicCertificatePath = Join-Path -Path $ConfigurationPath -ChildPath "RemoteSystemPublicCertificate.cer"
            $DomainDN = Get-DryADServiceProperty -Service 'domain' -Property 'DistinguishedName' -PSSession $PSSession
            $DomainFQDN = Get-DryADServiceProperty -Service 'domain' -Property 'DNSRoot' -PSSession $PSSession
            $DomainNB = Get-DryADServiceProperty -Service 'domain' -Property 'NetBIOSName' -PSSession $PSSession
            $ConfigurationNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'configurationNamingContext' -PSSession $PSSession
            $SchemaNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'schemaNamingContext' -PSSession $PSSession
            $SchemaMaster = Get-DryADServiceProperty -Service 'forest' -Property 'SchemaMaster' -PSSession $PSSession
        }
        else {
            $DomainDN = Get-DryADServiceProperty -Service 'domain' -Property 'DistinguishedName' -DomainController $DomainController
            $DomainFQDN = Get-DryADServiceProperty -Service 'domain' -Property 'DNSRoot' -DomainController $DomainController
            $DomainNB = Get-DryADServiceProperty -Service 'domain' -Property 'NetBIOSName' -DomainController $DomainController
            $ConfigurationNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'configurationNamingContext' -DomainController $DomainController
            $SchemaNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'schemaNamingContext' -DomainController $DomainController
            $SchemaMaster = Get-DryADServiceProperty -Service 'forest' -Property 'SchemaMaster' -DomainController $DomainController
        }

        # ! remove this when Tags are implemented
        if ($Tags) {
            throw "The parameter -Tags is not implemented yet!"
        }

        $SourceGPOsPath = Join-Path -Path $ConfigurationPath -ChildPath "gpo_imports"
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   VARIABLES
        #    
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        If ($VariablesPath) {
            If ($Variables) {
                ol w "You should not pass both `$Variables and `VariablesPath - select one"
                Throw "You should not pass both `$Variables and `VariablesPath - select one"
            }
            $Variables = Get-DryADJson -File $VariablesPath
        }

        $DefaultVariables = @('DomainDN', 'DomainFQDN', 'DomainNB', 'ConfigurationNC', 'SchemaNC')
        If ($ADSite) { $DefaultVariables += 'ADSite' }
        If ($ComputerName) { $DefaultVariables += 'ComputerName' }
        
        $DefaultVariables.ForEach({
                $CurrentDefaultVariable = $_
                If ($Null -eq ($Variables | Where-Object { $_.Name -eq $CurrentDefaultVariable })) {
                    $Variables += New-Object -TypeName PSObject -Property @{
                        Name  = "$CurrentDefaultVariable"
                        Value = Get-Variable -Name $CurrentDefaultVariable -Value
                    }
                }
            })
        
        # For debug
        $Variables.ForEach({
            Param($x)
            ol i @("Var: $($x.name)","$($x.Value)")
        })

        ol i 'Domain FQDN', "$DomainFQDN"
        ol i 'Domain NB', "$DomainNB"
        if ($ADSite) {
            ol i 'ADSite', "$ADSite"
        }
        elseif ($Null -ne ($Variables | Where-Object { $_.Name -eq 'ADSite' })) {
            [String]$ADSite = ($Variables | Where-Object { $_.Name -eq 'ADSite' }).Value
            ol i 'ADSite', "$ADSite"
        }
        
        If ($ComputerName) {
            ol i 'ComputerName', "$ComputerName"
        }
        elseif ($Null -ne ($Variables | Where-Object { $_.Name -eq 'ComputerName' })) {
            [String]$ComputerName = ($Variables | Where-Object { $_.Name -eq 'ComputerName' }).Value
            ol i 'ComputerName', "$ComputerName"
        }
        ol i ' ' -h
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   REPLACEMENT HASH
        #   Only used for json-formatted GPOs
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        $ReplacementHash = @{}
        foreach ($Var in $Variables) {
            $ReplacementHash.Add("###$($Var.Name)###", $Var.Value)
        }
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ROLE CONFIGURATION OBJECT
        #   Pick up all jsons (*.json) in $ConfigurationPath, and merge
        #   into $RoleConfiguration
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        Remove-Variable -Name RoleConfiguration, ADConfObject, ConfigurationPathFiles -ErrorAction Ignore
        $RoleConfiguration = New-Object -TypeName PSObject
        $ConfigurationPathFiles = @(Get-ChildItem -Path "$ConfigurationPath\*" -Include "*.jsonc", "*.json" -ErrorAction Stop)
        
        foreach ($ADConfFile in $ConfigurationPathFiles) {
            $ADConfObject = Get-DryADJson -Path $ADConfFile.FullName -ErrorAction Stop
            $RoleConfiguration = (Merge-DryADPSObjects -FirstObject $RoleConfiguration -SecondObject $ADConfObject)
        }
 
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   CASING
        #   Variables that specifies case modification of OUs, GPOs, groups and users.
        #   Valid values are 'upper', lower', 'capitalized' and 'ignore'. Defaults
        #   to ignore
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        [String]$OUCase    = 'ignore'
        [String]$GPOCase   = 'ignore'
        [String]$GroupCase = 'ignore'
        [String]$UserCase  = 'ignore'

        if ($RoleConfiguration.casing.ad_organizational_unit_case) {
            [String]$OUCase = $RoleConfiguration.casing.ad_organizational_unit_case
        }
        if ($RoleConfiguration.casing.ad_gpo_case) {
            [String]$GPOCase = $RoleConfiguration.casing.ad_gpo_case
        }
        if ($RoleConfiguration.casing.ad_group_case) { 
            [String]$GroupCase = $RoleConfiguration.casing.ad_group_case
        }
        if ($RoleConfiguration.casing.ad_user_case) { 
            [String]$UserCase = $RoleConfiguration.casing.ad_user_case
        }

        ol v 'Casing - OUs',    "$OUCase"
        ol v 'Casing - GPOs',   "$GPOCase"
        ol v 'Casing - Groups', "$GroupCase"
        ol v 'Casing - Users',  "$UserCase"

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   PROGRESS COUNTERS
        #   Counts configurations to process before start, to show
        #   a progress bar during configuration
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        [int]$ElementsCounter = 0
        [int]$NumberOfElementsToProcess = 0

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   AD SCHEMA
        #   Action: Get and Count 
        #   Dataset: $RoleConfiguration
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (Test-Path -Path "$ConfigurationPath\ad_schema" -ErrorAction Ignore) {
            if (($Types -icontains 'ad_schema') -or 
                ($Null -eq $Types)
            ) { 
                $ProcessADSchema = $True
                $ADSchemaExtensions = @(Get-ChildItem -Path "$ConfigurationPath\ad_schema\*" -Include "*.ldf")
                $NumberOfElementsToProcess += $ADSchemaExtensions.Count
            } 
            $NumberOfADSchemaExtensions = $ADSchemaExtensions.Count
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   NETLOGON
        #   Action: Count 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (Test-Path -Path "$ConfigurationPath\netlogon" -ErrorAction Ignore) {  
            if (($Types -icontains 'netlogon') -or 
                ($Null -eq $Types)
            ) { 
                $ProcessNETLOGON = $True
                $NumberOfElementsToProcess++
                $NumberOfNETLOGONs = 1
            } 
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   adm_templates
        #   Action: Count 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (Test-Path -Path "$ConfigurationPath\adm_templates" -ErrorAction Ignore) {  
            if (($Types -icontains 'adm_templates') -or ($Null -eq $Types)) { 
                $ProcessAdmTemplates = $True
                $NumberOfElementsToProcess++
            } 
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS
        #   Action: Get, Count and String Replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($RoleConfiguration.ou_schema) {
            # Elements have a scope; domain, site or computer.

            [Array]$DomainOUs += @($RoleConfiguration.ou_schema | 
                    Where-Object {  
                        $_.scope -contains 'domain' 
                    } )
           
            [Array]$SiteOUs += @($RoleConfiguration.ou_schema | 
                    Where-Object {  
                        $_.scope -contains 'site'
                    } )

            [Array]$ComputerOUs += @($RoleConfiguration.ou_schema | 
                    Where-Object {  
                        $_.scope -contains 'computer'
                    } )

            if (($Types -icontains 'ou_schema') -or ($Null -eq $Types)) { 
                $ProcessOUs = $True 
                $NumberOfElementsToProcess += (
                    $DomainOUs.Count + $SiteOUs.Count + $ComputerOUs.Count
                )
            }
        }

        # Replace all replacement patterns 
        if ($DomainOUs) {
            $DomainOUs = Resolve-DryADReplacementPatterns -inputobject $DomainOUs -Variables $Variables
        }
        if ($SiteOUs) {
            $SiteOUs = Resolve-DryADReplacementPatterns -inputobject $SiteOUs -Variables $Variables
        }
        if ($ComputerOUs) {
            $ComputerOUs = Resolve-DryADReplacementPatterns -inputobject $ComputerOUs -Variables $Variables
        }
        $NumberOfOUs = $DomainOUs.Count + $SiteOUs.Count + $ComputerOUs.Count

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS PATHS
        #   Action: Resolve Path from Paths
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        # DomainOUs that are missing 'path'-property must resolve it from 'paths'
        foreach ($OU in $DomainOUs | Where-Object { ($Null -eq $_.Path) -and ($Null -ne $_.Paths) }) {

            Remove-Variable -Name Path -ErrorAction Ignore
            $Path = $OU.paths.domain

            if ($Null -eq $Path) {
                ol e "Unable to find `$OU.paths.domain on '$($OU.alias)'"
                throw "Unable to find `$OU.paths.domain on '$($OU.alias)'"
            }
            elseif ($Path -is [Array]) {
                ol e "Multiple definitions `$OU.paths.domain on '$($OU.alias)'"
                throw "Multiple definitions `$OU.paths.domain on '$($OU.alias)'"
            }
            
            # Add Path property, then remove .paths 
            $OU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
            $OU.PSObject.Properties.Remove('paths')
            
            Remove-Variable -Name Path -ErrorAction Ignore
        }

        # SiteOUs that are missing 'path'-property must resolve it from 'paths'
        foreach ($OU in $SiteOUs | Where-Object { ($Null -eq $_.Path) -and ($Null -ne $_.Paths) }) {

            Remove-Variable -Name Path -ErrorAction Ignore
            $Path = $OU.paths.site

            if ($Null -eq $Path) {
                ol e "Unable to find `$OU.paths.Site on '$($OU.alias)'"
                throw "Unable to find `$OU.paths.Site on '$($OU.alias)'"
            }
            elseif ($Path -is [Array]) {
                ol e "Multiple definitions `$OU.paths.Site on '$($OU.alias)'"
                throw "Multiple definitions `$OU.paths.Site on '$($OU.alias)'"
            }
            
            # Add Path property, then remove .paths 
            $OU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
            $OU.PSObject.Properties.Remove('paths')
            
            Remove-Variable -Name Path -ErrorAction Ignore
        }

        # ComputerOUs that are missing 'path'-property must resolve it from 'paths'
        foreach ($OU in $ComputerOUs | Where-Object { ($Null -eq $_.Path) -and ($Null -ne $_.Paths) }) {

            Remove-Variable -Name Path -ErrorAction Ignore
            $Path = $OU.paths.computer

            if ($Null -eq $Path) {
                ol e "Unable to find `$OU.paths.computer on '$($OU.alias)'"
                throw "Unable to find `$OU.paths.computer on '$($OU.alias)'"
            }
            elseif ($Path -is [Array]) {
                ol e "Multiple definitions `$OU.paths.computer on '$($OU.alias)'"
                throw "Multiple definitions `$OU.paths.computer on '$($OU.alias)'"
            }
            
            # Add Path property, then remove .paths 
            $OU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
            $OU.PSObject.Properties.Remove('paths')
            
            Remove-Variable -Name Path -ErrorAction Ignore
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS PATHS
        #   Action: Resolve Child Paths from Parents
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        
        $AnOUWasResolved = $True
        do {
            $AnOUWasResolved = $False 
            # Loop through DomainOUs that already have a path
            foreach ($ResolvedOU in $DomainOUs | 
                    Where-Object { 
                        $null -ne $_.path 
                    }) {
                
                # Loop through DomainOUs that do not have a path
                foreach ($UnresolvedOU in $DomainOUs | 
                        Where-Object { 
                            $null -eq $_.path 
                        }) {
                    try {
                        Remove-Variable -Name Parent -ErrorAction Ignore
                        $Parent = $UnresolvedOU.parents | 
                            Where-Object { 
                            ($_.parentscope -eq 'domain') -and
                            ($_.scope -eq 'domain') -and
                            ($_.alias -eq $ResolvedOU.alias) 
                            }
                        
                        if ($Parent) {
                            $Path = Get-DryADOUPathFromAlias -Alias $Parent.alias -OUs $DomainOUs -Scope 'domain' -Child $Parent.child
                            $AnOUWasResolved = $True
                            # Add Path property 
                            $UnresolvedOU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
                            # Once resolved, remove parents 
                            $UnresolvedOU.PSObject.Properties.Remove('parents')
                        }
                    }
                    catch {
                        $PSCmdLet.ThrowTerminatingError($_)
                    }
                    finally {
                        Remove-Variable -Name Path, Parent -ErrorAction Ignore
                    }
                }

                # Loop through SiteOUs that do not have a path
                foreach ($UnresolvedOU in $SiteOUs | 
                        Where-Object { 
                            $null -eq $_.path 
                        }) {
                    try {
                        Remove-Variable -Name Parent -ErrorAction Ignore
                        $Parent = $UnresolvedOU.parents | 
                            Where-Object { 
                            ($_.parentscope -eq 'domain') -and
                            ($_.scope -eq 'site') -and
                            ($_.alias -eq $ResolvedOU.alias) 
                            }
                        
                        if ($Parent) {
                            $Path = Get-DryADOUPathFromAlias -Alias $Parent.alias -OUs $DomainOUs -Scope 'site' -Child $Parent.child
                            $AnOUWasResolved = $True
                            # Add Path property 
                            $UnresolvedOU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
                            # Once resolved, remove parents 
                            $UnresolvedOU.PSObject.Properties.Remove('parents')
                        }
                    }
                    catch {
                        $PSCmdLet.ThrowTerminatingError($_)
                    }
                    finally {
                        Remove-Variable -Name Path, Parent -ErrorAction Ignore
                    }
                }

                # Loop through ComputerOUs that do not have a path
                foreach ($UnresolvedOU in $ComputerOUs | 
                        Where-Object { 
                            $null -eq $_.path 
                        }) {
                    try {
                        Remove-Variable -Name Parent -ErrorAction Ignore
                        $Parent = $UnresolvedOU.parents | 
                            Where-Object { 
                            ($_.parentscope -eq 'domain') -and
                            ($_.scope -eq 'computer') -and
                            ($_.alias -eq $ResolvedOU.alias) 
                            }
                        
                        if ($Parent) {
                            $Path = Get-DryADOUPathFromAlias -Alias $Parent.alias -OUs $DomainOUs -Scope 'computer' -Child $Parent.child
                            $AnOUWasResolved = $True
                            # Add Path property 
                            $UnresolvedOU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
                            # Once resolved, remove parents 
                            $UnresolvedOU.PSObject.Properties.Remove('parents')
                        }
                    }
                    catch {
                        $PSCmdLet.ThrowTerminatingError($_)
                    }
                    finally {
                        Remove-Variable -Name Path, Parent -ErrorAction Ignore
                    }
                }
            }

            # Loop through SiteOUs that already have a path
            foreach ($ResolvedOU in $SiteOUs | 
                    Where-Object { 
                        $null -ne $_.Path 
                    }) {
                # Loop through SiteOUs that do not have a path
                foreach ($UnresolvedOU in $SiteOUs | 
                        Where-Object { 
                            $null -eq $_.path 
                        }) {
                    try {
                        Remove-Variable -Name Parent -ErrorAction Ignore
                        $Parent = $UnresolvedOU.parents | 
                            Where-Object { 
                            ($_.parentscope -eq 'site') -and
                            ($_.scope -eq 'site') -and
                            ($_.alias -eq $ResolvedOU.alias) 
                            }
                        
                        if ($Parent) {
                            $Path = Get-DryADOUPathFromAlias -Alias $Parent.alias -OUs $SiteOUs -Scope 'site' -Child $Parent.child
                            $AnOUWasResolved = $True
                            # Add Path property 
                            $UnresolvedOU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
                            # Once resolved, remove parents 
                            $UnresolvedOU.PSObject.Properties.Remove('parents')
                        }
                    }
                    catch {
                        $PSCmdLet.ThrowTerminatingError($_)
                    }
                    finally {
                        Remove-Variable -Name Path, Parent -ErrorAction Ignore
                    }
                }

                # Loop through ComputerOUs that do not have a path
                foreach ($UnresolvedOU in $ComputerOUs | 
                        Where-Object { 
                            $null -eq $_.path 
                        }) {
                    try {
                        Remove-Variable -Name Parent -ErrorAction Ignore
                        $Parent = $UnresolvedOU.parents | 
                            Where-Object { 
                            ($_.parentscope -eq 'site') -and
                            ($_.scope -eq 'computer') -and
                            ($_.alias -eq $ResolvedOU.alias) 
                            }
                        
                        if ($Parent) {
                            $Path = Get-DryADOUPathFromAlias -Alias $Parent.alias -OUs $SiteOUs -Scope 'computer' -Child $Parent.child
                            $AnOUWasResolved = $True
                            # Add Path property 
                            $UnresolvedOU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
                            # Once resolved, remove parents 
                            $UnresolvedOU.PSObject.Properties.Remove('parents')
                        }
                    }
                    catch {
                        $PSCmdLet.ThrowTerminatingError($_)
                    }
                    finally {
                        Remove-Variable -Name Path, Parent -ErrorAction Ignore
                    }
                }
            }

            # Loop through ComputerOUs that already have a path
            foreach ($ResolvedOU in $ComputerOUs | 
                    Where-Object { 
                        $null -ne $_.Path 
                    }) {

                # Loop through ComputerOUs that do not have a path
                foreach ($UnresolvedOU in $ComputerOUs | 
                        Where-Object { 
                            $null -eq $_.path 
                        }) {
                    try {
                        Remove-Variable -Name Parent -ErrorAction Ignore
                        $Parent = $UnresolvedOU.parents | 
                            Where-Object { 
                            ($_.parentscope -eq 'computer') -and
                            ($_.scope -eq 'computer') -and
                            ($_.alias -eq $ResolvedOU.alias) 
                            }
                        
                        if ($Parent) {
                            $Path = Get-DryADOUPathFromAlias -Alias $Parent.Alias -OUs $ComputerOUs -Scope 'computer' -Child $Parent.child
                            $AnOUWasResolved = $True
                            # Add Path property 
                            $UnresolvedOU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
                            # Once resolved, remove parents 
                            $UnresolvedOU.PSObject.Properties.Remove('parents')
                        }
                    }
                    catch {
                        $PSCmdLet.ThrowTerminatingError($_)
                    }
                    finally {
                        Remove-Variable -Name Path, Parent -ErrorAction Ignore
                    }
                }
            }  
        }
        While ($AnOUWasResolved)

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS PATHS
        #   Action: Display resolved paths
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($DomainOUs.count -gt 0) {
            ol i "Resolved Domain OU Aliases" -sh 
            foreach ($OU in $DomainOUs) {
                ol i "$($OU.Alias)", "$($OU.Path)"
            }
        }
        
        if ($SiteOUs.count -gt 0) {
            ol i "Resolved Site OU Aliases" -sh 
            foreach ($OU in $SiteOUs) {
                ol i "$($OU.Alias)", "$($OU.Path)"
            }
        }
        
        if ($ComputerOUs.count -gt 0) {
            ol i "Resolved Computer OU Aliases" -sh 
            foreach ($OU in $ComputerOUs) {
                ol i "$($OU.Alias)", "$($OU.Path)"
            }
        }
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS PATHS
        #   Action: Convert To 'distinguishedName' and Correct Case
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        foreach ($OU in $DomainOUs) {
            $OU.Path = ConvertTo-DryADDistinguishedName -Name $OU.Path -Case $OUcase
            ol d "Domain OU dN for $($OU.Alias) is: '$($OU.Path)'" 
        }
        foreach ($OU in $SiteOUs) {
            $OU.Path = ConvertTo-DryADDistinguishedName -Name $OU.Path -Case $OUcase
            ol d "Site OU dN for $($OU.Alias) is: '$($OU.Path)'" 
        }
        foreach ($OU in $ComputerOUs) {
            $OU.Path = ConvertTo-DryADDistinguishedName -Name $OU.Path -Case $OUcase
            ol d "Site OU dN for $($OU.Alias) is: '$($OU.Path)'" 
        }
        

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   WMI Filter Imports and Links
        #   Action: Get, Count and String Replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (
            ($Types -icontains 'wmi_filters') -or 
            ($Types -icontains 'wmi_filters_links') -or 
            ($Null -eq $Types)
        ) { 
            if ($RoleConfiguration.wmi_filters) {
                
                # Get the elements
                [Array]$DomainWMIFilters += @($RoleConfiguration.wmi_filters | Where-Object {  
                        $_.scope -eq 'domain' 
                    } )
            
                [Array]$SiteWMIFilters += @($RoleConfiguration.wmi_filters | Where-Object {  
                        $_.scope -eq 'site'
                    } )

                [Array]$ComputerWMIFilters += @($RoleConfiguration.wmi_filters | Where-Object {  
                        $_.scope -eq 'computer'
                    } )

                # Replace any replacement pattern 
                $DomainWMIFilters = Resolve-DryADReplacementPatterns -inputobject $DomainWMIFilters -Variables $Variables
                $SiteWMIFilters = Resolve-DryADReplacementPatterns -inputobject $SiteWMIFilters -Variables $Variables
                $ComputerWMIFilters = Resolve-DryADReplacementPatterns -inputobject $ComputerWMIFilters -Variables $Variables

                # Count the wmi_filters, but only if we're actually importing them
                if (
                    ($Types -icontains 'wmi_filters') -or 
                    ($Null -eq $Types)
                ) {
                    $ProcessWMIFilterImports = $True
                    $NumberOfElementsToProcess += ($DomainWMIFilters.Count + $SiteWMIFilters.Count + $ComputerWMIFilters.Count)
                    $NumberOfWMIFilters += ($DomainWMIFilters.Count + $SiteWMIFilters.Count + $ComputerWMIFilters.Count)
                }

                if (
                    ($Types -icontains 'wmi_filters_links') -or 
                    ($Null -eq $Types)
                ) {
                    $ProcessWMIFilterLinks = $True
                    $DomainWmiFilterLinksCount = 0
                    $DomainWMIFilters.ForEach({
                            $_.links.ForEach({
                                    $DomainWmiFilterLinksCount++
                                })
                        })

                    $SiteWmiFilterLinksCount = 0
                    $SiteWMIFilters.ForEach({
                            $_.links.ForEach({
                                    $SiteWmiFilterLinksCount++
                                })
                        })
                    $ComputerWmiFilterLinksCount = 0
                    $ComputerWMIFilters.ForEach({
                            $_.links.ForEach({
                                    $ComputerWmiFilterLinksCount++
                                })
                        })
                    $NumberOfWMIFilterLinks = $DomainWmiFilterLinksCount + $SiteWmiFilterLinksCount + $ComputerWmiFilterLinksCount
                    $NumberOfElementsToProcess += $NumberOfWMIFilterLinks
                }
            }
        }


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   RIGHTS GROUPS
        #   Action: Get, Count, String Replacement, Resolve Paths and Convert Case
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($RoleConfiguration.rights_groups) {
            
            # Get domain scoped rights groups
            $DomainRightsGroups = @($RoleConfiguration.rights_groups | Where-Object {  
                    $_.scope -eq 'domain' 
                } )
            
            # Get site scoped rights groups
            $SiteRightsGroups = @($RoleConfiguration.rights_groups | Where-Object {  
                    $_.scope -eq 'site' 
                } )

            # Get computer scoped rights groups
            $ComputerRightsGroups = @($RoleConfiguration.rights_groups | Where-Object {  
                    $_.scope -eq 'computer' 
                } )

            # Count
            if (
                ($Types -icontains 'rights_groups') -or 
                ($Null -eq $Types)
            ) { 
                $ProcessRightsGroups = $True
                $NumberOfElementsToProcess += ($DomainRightsGroups.Count + $SiteRightsGroups.Count + $ComputerRightsGroups.Count) 
                $NumberOfRightsGroups = ($DomainRightsGroups.Count + $SiteRightsGroups.Count + $ComputerRightsGroups.Count)
            }
            
            # Replace any replacement pattern 
            # Replace regardless of $Types -icontains 'rights_groups', since RightsGroups are referenced by Rights, GroupMembers and GPOImports
            $DomainRightsGroups = Resolve-DryADReplacementPatterns -inputobject $DomainRightsGroups -Variables $Variables
            $SiteRightsGroups = Resolve-DryADReplacementPatterns -inputobject $SiteRightsGroups -Variables $Variables
            $ComputerRightsGroups = Resolve-DryADReplacementPatterns -inputobject $ComputerRightsGroups -Variables $Variables

            # Resolve Domain OU Paths from schema
            foreach ($RightsGroup in $DomainRightsGroups) {
                if ($NULL -eq $RightsGroup.path) {

                    # Resolve domain paths from OU schema
                    $Path = Get-DryADOUPathFromAlias -Alias $RightsGroup.Alias -OUs $DomainOUs -Scope 'domain'
                    $RightsGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase 
                $RightsGroup.groupname = ConvertTo-DryADCase -Name $RightsGroup.groupname -Case $Groupcase
            }

            # Resolve Site OU Paths from schema
            foreach ($RightsGroup in $SiteRightsGroups) {
                if ($NULL -eq $RightsGroup.path) {

                    # Resolve domain paths from OU schema
                    $Path = Get-DryADOUPathFromAlias -Alias $RightsGroup.Alias -OUs $SiteOUs -Scope 'site'
                    $RightsGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase
                $RightsGroup.groupname = ConvertTo-DryADCase -Name $RightsGroup.groupname -Case $Groupcase
            }

            # Resolve Site OU Paths from schema
            foreach ($RightsGroup in $ComputerRightsGroups) {
                if ($NULL -eq $RightsGroup.path) {

                    # Resolve domain paths from OU schema
                    $Path = Get-DryADOUPathFromAlias -Alias $RightsGroup.Alias -OUs $ComputerOUs -Scope 'computer'
                    $RightsGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase
                $RightsGroup.groupname = ConvertTo-DryADCase -Name $RightsGroup.groupname -Case $Groupcase
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ROLE GROUPS
        #   Action: Count and String replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($RoleConfiguration.role_groups) {
            
            # Get domain scoped rights groups
            $DomainRoleGroups = @($RoleConfiguration.role_groups | Where-Object {  
                    $_.scope -eq 'domain' 
                } )
            
            # Get site scoped rights groups
            $SiteRoleGroups = @($RoleConfiguration.role_groups | Where-Object {  
                    $_.scope -eq 'site' 
                } )

            # Get computer scoped rights groups
            $ComputerRoleGroups = @($RoleConfiguration.role_groups | Where-Object {  
                    $_.scope -eq 'computer' 
                } )

            # Count
            if (
                ($Types -icontains 'role_groups') -or 
                ($Null -eq $Types)
            ) { 
                $ProcessRoleGroups = $True
                $NumberOfElementsToProcess += ($DomainRoleGroups.Count + $SiteRoleGroups.Count + $ComputerRoleGroups.Count)
                $NumberOfRoleGroups = ($DomainRoleGroups.Count + $SiteRoleGroups.Count + $ComputerRoleGroups.Count) 
            }

            # Replace any replacement pattern 
            # Replace regardless of $Types -icontains 'rights_groups', since groups are referenced by -component GroupMembers
            $DomainRoleGroups = @(Resolve-DryADReplacementPatterns -inputobject $DomainRoleGroups -Variables $Variables)
            $SiteRoleGroups = @(Resolve-DryADReplacementPatterns -inputobject $SiteRoleGroups -Variables $Variables)
            $ComputerRoleGroups = @(Resolve-DryADReplacementPatterns -inputobject $ComputerRoleGroups -Variables $Variables)


            # Resolve domain OU paths from schema
            foreach ($RoleGroup in $DomainRoleGroups) {
                if ($NULL -eq $RoleGroup.path) {
                    # Resolve domain paths from OU schema
                    $Path = Get-DryADOUPathFromAlias -Alias $RoleGroup.Alias -OUs $DomainOUs -Scope 'domain'
                    $RoleGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase 
                $RoleGroup.groupname = ConvertTo-DryADCase -Name $RoleGroup.groupname -Case $Groupcase
            }

            # Resolve site OU paths from schema
            foreach ($RoleGroup in $SiteRoleGroups) {
                if ($NULL -eq $RoleGroup.path) {
                    # Resolve site paths from OU schema
                    $Path = Get-DryADOUPathFromAlias -Alias $RoleGroup.Alias -OUs $SiteOUs -Scope 'site'
                    $RoleGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase
                $RoleGroup.groupname = ConvertTo-DryADCase -Name $RoleGroup.groupname -Case $Groupcase
            }

            # Resolve computer OU paths from schema
            foreach ($RoleGroup in $ComputerRoleGroups) {
                if ($NULL -eq $RoleGroup.path) {
                    # Resolve site paths from OU schema
                    $Path = Get-DryADOUPathFromAlias -Alias $RoleGroup.Alias -OUs $ComputerOUs -Scope 'computer'
                    $RoleGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase
                $RoleGroup.groupname = ConvertTo-DryADCase -Name $RoleGroup.groupname -Case $Groupcase
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP MEMBERS
        #   Action: Count
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        # Count Members and MemberOfs
        $NumberOfMemberAndMemberOf = 0
        $NumberOfDomainMemberAndMemberOf = 0
        $NumberOfSiteMemberAndMemberOf = 0
        $NumberOfComputerMemberAndMemberOf = 0
        if (
            ($Types -icontains 'group_members') -or 
            ($Null -eq $Types)
        ) { 
            $ProcessGroupMembers = $True
            
            # Domain Scope - Both Role and Rights groups may have .member and .memberof 
            foreach ($DomainRoleGroup in $DomainRoleGroups) {
                $NumberOfDomainMemberAndMemberOf += $DomainRoleGroup.Member.Count
                $NumberOfDomainMemberAndMemberOf += $DomainRoleGroup.MemberOf.Count
            }

            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                $NumberOfDomainMemberAndMemberOf += $DomainRightsGroup.Member.Count
                $NumberOfDomainMemberAndMemberOf += $DomainRightsGroup.MemberOf.Count
            }
            $NumberOfElementsToProcess += $NumberOfDomainMemberAndMemberOf
            $NumberOfMemberAndMemberOf += $NumberOfDomainMemberAndMemberOf
            
            # Site Scope - Both Role and Rights groups may have .member and .memberof 
            foreach ($SiteRoleGroup in $SiteRoleGroups) {
                $NumberOfSiteMemberAndMemberOf += $SiteRoleGroup.Member.Count
                $NumberOfSiteMemberAndMemberOf += $SiteRoleGroup.MemberOf.Count
            }

            foreach ($SiteRightsGroup in $SiteRightsGroups) {
                $NumberOfSiteMemberAndMemberOf += $SiteRightsGroup.Member.Count
                $NumberOfSiteMemberAndMemberOf += $SiteRightsGroup.MemberOf.Count
            }
            $NumberOfElementsToProcess += $NumberOfSiteMemberAndMemberOf
            $NumberOfMemberAndMemberOf += $NumberOfSiteMemberAndMemberOf

            # Computer Scope - Both Role and Rights groups may have .member and .memberof 
            foreach ($ComputerRoleGroup in $ComputerRoleGroups) {
                $NumberOfComputerMemberAndMemberOf += $ComputerRoleGroup.Member.Count
                $NumberOfComputerMemberAndMemberOf += $ComputerRoleGroup.MemberOf.Count

            }

            foreach ($ComputerRightsGroup in $ComputerRightsGroups) {
                $NumberOfComputerMemberAndMemberOf += $ComputerRightsGroup.Member.Count
                $NumberOfComputerMemberAndMemberOf += $ComputerRightsGroup.MemberOf.Count

            }
            $NumberOfElementsToProcess += $NumberOfComputerMemberAndMemberOf
            $NumberOfMemberAndMemberOf += $NumberOfComputerMemberAndMemberOf
        }


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   RIGHTS
        #   Action: Count and Resolve Paths
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (
            ($Types -icontains 'rights') -or 
            ($Null -eq $Types)
        ) { 
            $ProcessRights = $True
            
            # Count and resolve domain Path
            $NumberOfRights = 0 
            $NumberOfDomainRights = 0
            $NumberOfSiteRights = 0
            $NumberOfComputerRights = 0

            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                foreach ($DomainRight in $DomainRightsGroup.Rights) {
                    $NumberOfElementsToProcess++
                    # Update the debug counter as well
                    $NumberOfRights++
                    $NumberOfDomainRights++
                    # Resolve Path
                    if ($Null -eq $DomainRight.Path) {

                        # Resolve paths from OU schema. It is possible to set a domain right 
                        # at a site- or computer-scoped OU  
                        switch ($DomainRight.Scope) {
                            'domain' {
                                $Path = Get-DryADOUPathFromAlias -Alias $DomainRight.Alias -OUs $DomainOUs -Scope 'domain'
                            }
                            'site' {
                                $Path = Get-DryADOUPathFromAlias -Alias $DomainRight.Alias -OUs $SiteOUs -Scope 'site'
                            }
                            'computer' {
                                $Path = Get-DryADOUPathFromAlias -Alias $DomainRight.Alias -OUs $ComputerOUs -Scope 'computer'
                            }
                        }
                        $DomainRight | Add-Member -MemberType NoteProperty -Name Path -Value $Path

                        # Once resolved, remove Alias. Keep scope - we need that to determine if the target scope, or
                        # IdentityReeference, is a site or domain path
                        $DomainRight.PSObject.Properties.Remove('Alias')
                    }
                }
            }

            # Count and resolve site Path
            foreach ($SiteRightsGroup in $SiteRightsGroups) {
                foreach ($SiteRight in $SiteRightsGroup.Rights) {
                    $NumberOfElementsToProcess++
                    $NumberOfRights++
                    $NumberOfSiteRights++
            
                    # Resolve Path
                    if ($Null -eq $SiteRight.Path) {
                        
                        # Resolve domain paths from OU schema. A right for a site group may 
                        # reference an OU in the domain scope, site scope or computer scope
                        switch ($SiteRight.Scope) {
                            'domain' {
                                $Path = Get-DryADOUPathFromAlias -Alias $SiteRight.Alias -OUs $DomainOUs -Scope 'domain'
                            }
                            'site' {
                                $Path = Get-DryADOUPathFromAlias -Alias $SiteRight.Alias -OUs $SiteOUs -Scope 'site'
                            }
                            'computer' {
                                $Path = Get-DryADOUPathFromAlias -Alias $SiteRight.Alias -OUs $ComputerOUs -Scope 'computer'
                            }
                        }
                        
                        $SiteRight | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                        
                        # Once resolved, remove Alias. Leave Scope, we may need that
                        $SiteRight.PSObject.Properties.Remove('Alias')
                    }
                }
            }

            # Count and resolve computer Path
            foreach ($ComputerRightsGroup in $ComputerRightsGroups) {
                foreach ($ComputerRight in $ComputerRightsGroup.Rights) {
                    $NumberOfElementsToProcess++
                    $NumberOfRights++
                    $NumberOfComputerRights++
            
                    # Resolve Path
                    if ($Null -eq $ComputerRight.Path) {
                        
                        # Resolve domain paths from OU schema. A right for a computer group may 
                        # reference an OU in the domain scope, or in the site scope
                        switch ($ComputerRight.Scope) {
                            'domain' {
                                $Path = Get-DryADOUPathFromAlias -Alias $ComputerRight.Alias -OUs $DomainOUs -Scope 'domain'
                            }
                            'site' {
                                $Path = Get-DryADOUPathFromAlias -Alias $ComputerRight.Alias -OUs $SiteOUs -Scope 'site'
                            }
                            'computer' {
                                $Path = Get-DryADOUPathFromAlias -Alias $ComputerRight.Alias -OUs $ComputerOUs -Scope 'computer'
                            }
                        }
                        
                        $ComputerRight | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                        
                        # Once resolved, remove Alias. Leave Scope, we may need that
                        $ComputerRight.PSObject.Properties.Remove('Alias')
                    }
                }
            }
        }


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICY IMPORTS
        #   Action: Count and String replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (
            ($Types -icontains 'gpo_imports') -or 
            ($Null -eq $Types)
        ) {  
            
            if ($RoleConfiguration.gpo_imports) {   
                $ProcessGPOImports = $True   
                $DomainGPOImports = @($RoleConfiguration.gpo_imports | Where-Object {  
                        $_.scope -eq 'domain' 
                    })
                
                $SiteGPOImports = @($RoleConfiguration.gpo_imports | Where-Object {  
                        $_.scope -eq 'site' 
                    })

                $ComputerGPOImports = @($RoleConfiguration.gpo_imports | Where-Object {  
                        $_.scope -eq 'computer' 
                    })

                # If the configuration set contains json-gpos, 
                $JsonGPOImports = @($RoleConfiguration.gpo_imports | Where-Object {  
                        $_.type -eq 'json' 
                    })
                $RequiresGPOHelper = $False
                if ($JsonGPOImports.count -gt 0) {
                    $RequiresGPOHelper = $True
                }
 
                $NumberOfElementsToProcess += ($DomainGPOImports.Count + $SiteGPOImports.Count + $ComputerGPOImports.Count)
                $NumberOfGPOImports += ($DomainGPOImports.Count + $SiteGPOImports.Count + $ComputerGPOImports.Count)

                $DomainGPOImports = Resolve-DryADReplacementPatterns -inputobject $DomainGPOImports -Variables $Variables
                $SiteGPOImports = Resolve-DryADReplacementPatterns -inputobject $SiteGPOImports -Variables $Variables
                $ComputerGPOImports = Resolve-DryADReplacementPatterns -inputobject $ComputerGPOImports -Variables $Variables
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICY LINKS
        #   Action: Count, String replacement and Resolve paths from aliases
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (
            ($Types -icontains 'gpo_links') -or
            ($Null -eq $Types)
        ) {  
            if ($RoleConfiguration.gpo_links) {  

                $ProcessGPOLinks = $True
                
                $DomainGPOLinks = @($RoleConfiguration.gpo_links | Where-Object {  
                        $_.scope -eq 'domain' 
                    } )
                
                $SiteGPOLinks = @($RoleConfiguration.gpo_links | Where-Object {  
                        $_.scope -eq 'site' 
                    } )

                $ComputerGPOLinks = @($RoleConfiguration.gpo_links | Where-Object {  
                        $_.scope -eq 'computer' 
                    } )
                
                $NumberOfElementsToProcess += ($DomainGPOLinks.Count + $SiteGPOLinks.Count + $ComputerGPOLinks.Count)
                $NumberOfGPOLinks = ($DomainGPOLinks.Count + $SiteGPOLinks.Count + $ComputerGPOLinks.Count)

                # String Replacements
                $DomainGPOLinks = Resolve-DryADReplacementPatterns -inputobject $DomainGPOLinks -Variables $Variables
                $SiteGPOLinks = Resolve-DryADReplacementPatterns -inputobject $SiteGPOLinks -Variables $Variables
                $ComputerGPOLinks = Resolve-DryADReplacementPatterns -inputobject $ComputerGPOLinks -Variables $Variables 
                
                # Resolve Domain Paths from OU schema
                foreach ($DomainGPOLink in $DomainGPOLinks) {
                    if ($NULL -eq $DomainGPOLink.path) {
                        $Path = Get-DryADOUPathFromAlias -Alias $DomainGPOLink.Alias -OUs $DomainOUs -Scope 'domain'
                        $DomainGPOLink | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                }

                # Resolve Site Paths from OU schema
                foreach ($SiteGPOLink in $SiteGPOLinks) {
                    if ($NULL -eq $SiteGPOLink.path) {
                        $Path = Get-DryADOUPathFromAlias -Alias $SiteGPOLink.Alias -OUs $SiteOUs -Scope 'site'
                        $SiteGPOLink | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                }

                # Resolve Computer Paths from OU schema
                foreach ($ComputerGPOLink in $ComputerGPOLinks) {
                    if ($NULL -eq $ComputerGPOLink.path) {
                        $Path = Get-DryADOUPathFromAlias -Alias $ComputerGPOLink.Alias -OUs $ComputerOUs -Scope 'computer'
                        $ComputerGPOLink | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                }
            } 
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USERS
        #   Action: Count, String replacement, resolve OUs
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (
            ($Types -icontains 'users') -or 
            ($Null -eq $Types)
        ) {  
            if ($RoleConfiguration.users) {
                
                # Get domain scoped users
                $DomainUsers = @($RoleConfiguration.users | Where-Object {  
                        $_.scope -eq 'domain' 
                    } )
                
                # Get site scoped users
                $SiteUsers = @($RoleConfiguration.users | Where-Object {  
                        $_.scope -eq 'site' 
                    } )

                # Get computer scoped users
                $ComputerUsers = @($RoleConfiguration.users | Where-Object {  
                        $_.scope -eq 'computer' 
                    } )

                # Count
                if (
                    ($Types -icontains 'users') -or 
                    ($Null -eq $Types)
                ) { 
                    $ProcessUsers = $True
                    $NumberOfElementsToProcess += ($DomainUsers.Count + $SiteUsers.Count + $ComputerUsers.Count)
                    $NumberOfUsers = ($DomainUsers.Count + $SiteUsers.Count + $ComputerUsers.Count) 
                }

                # Replace any replacement pattern 
                if ($DomainUsers.count -gt 0) {
                    $DomainUsers = @(Resolve-DryADReplacementPatterns -inputobject $DomainUsers -Variables $Variables)
                }
                if ($SiteUsers.count -gt 0) {
                    $SiteUsers = @(Resolve-DryADReplacementPatterns -inputobject $SiteUsers -Variables $Variables)
                }
                if ($ComputerUsers.count -gt 0) {
                    $ComputerUsers = @(Resolve-DryADReplacementPatterns -inputobject $ComputerUsers -Variables $Variables)
                }

                # Resolve domain OU paths from schema
                foreach ($User in $DomainUsers) {
                    if ($NULL -eq $User.path) {
                        # Resolve domain paths from OU schema
                        $Path = Get-DryADOUPathFromAlias -Alias $User.Alias -OUs $DomainOUs -Scope 'domain'
                        $User | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                    # Convert to $GroupCase
                    $User.name = ConvertTo-DryADCase -Name $User.name -Case $UserCase
                }

                # Resolve site OU paths from schema
                foreach ($User in $SiteUsers) {
                    if ($NULL -eq $User.path) {
                        # Resolve site paths from OU schema
                        $Path = Get-DryADOUPathFromAlias -Alias $User.Alias -OUs $SiteOUs -Scope 'site'
                        $User | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                    # Convert to $GroupCase
                    $User.name = ConvertTo-DryADCase -Name $User.name -Case $UserCase
                }

                # Resolve computer OU paths from schema
                foreach ($User in $ComputerUsers) {
                    if ($NULL -eq $User.path) {
                        # Resolve site paths from OU schema
                        $Path = Get-DryADOUPathFromAlias -Alias $User.Alias -OUs $ComputerOUs -Scope 'computer'
                        $User | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                    # Convert to $GroupCase
                    $User.name = ConvertTo-DryADCase -Name $User.name -Case $UserCase
                }
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USER'S GROUP MEMBERSHIPS
        #   Action: Count
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (($Types -icontains 'users_memberof') -or 
            ($Null -eq $types)) {  
            
            $ProcessUserMemberOf = $True
            # Count User's MemberOfs
            $NumberOfDomainUserMemberOf = 0
            $NumberOfSiteUserMemberOf = 0
            $NumberOfComputerUserMemberOf = 0
                 
            # Domain Scope 
            foreach ($DomainUser in $DomainUsers) {
                $NumberOfDomainUserMemberOf += $DomainUser.MemberOf.Count
            }
            $NumberOfElementsToProcess += $NumberOfDomainUserMemberOf
            
            # Site Scope 
            foreach ($SiteUser in $SiteUsers) {
                $NumberOfSiteUserMemberOf += $SiteUser.MemberOf.Count
            }
            $NumberOfElementsToProcess += $NumberOfSiteUserMemberOf

            # Computer Scope 
            foreach ($ComputerUser in $ComputerUsers) {
                $NumberOfComputerUserMemberOf += $ComputerUser.MemberOf.Count

            }
            $NumberOfElementsToProcess += $NumberOfComputerUserMemberOf
            
            $NumberOfUserMemberOf = $NumberOfDomainUserMemberOf + $NumberOfSiteUserMemberOf + $NumberOfComputerUserMemberOf
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   AD DRIVE
        #   Action: Make sure the AD Drive on the executing system is created when 
        #   importing the ActiveDirectory module, and that it points to the correct
        #   Domain Controller.  
        #   - If Remote execution, we remote into a Domain Controller, and the AD 
        #     drive should be pointed to localhost. 
        #   - If Local execution, the AD Drive should point to $DomainController
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        
        switch ($ExecutionType) {
            'Remote' {
                ol i "Configuring AD Drive on $($PSSession.ComputerName)" -sh
                Set-DryADDrive -PSSession $PSSession
            }
            'Local' {
                ol i "Configuring AD Drive on local system" -sh
                Set-DryADDrive -DomainController $DomainController
            }
        }
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   AD WEB SERVICES ON DOMAIN CONTROLLER
        #   Action: Test, and wait for the service to become available
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ExecutionType -eq 'Remote') {
            ol i "Testing and Waiting for AD Availability" -sh
            Wait-DryADForADWebServices -DomainDN $DomainDN -PSSession $PSSession
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   SCHEMA UPDATES 
        #   Action: Invoke/Update. Will only work when 'Remote' and $DomainController 
        #   is the Schema Master
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessADSchema) {

            ol i "AD Schema Extensions ($($ADSchemaExtensions.count))" -sh
            foreach ($ADSchemaExtension in $ADSchemaExtensions) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Schema extension: $($ADSchemaExtension.BaseName)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                $ADSchemaExtJson = Get-Content -Path (Join-Path -Path (Split-Path -Path $ADSchemaExtension.FullName) -ChildPath "$($ADSchemaExtension.BaseName).json") |
                    ConvertFrom-Json -ErrorAction 'Stop'

                $ADSchemaExtContent = Get-Content -Path $ADSchemaExtension.FullName -Raw -ErrorAction 'Stop'

                $ExtendDryADSchemaParams = @{
                    Type         = $ADSchemaExtension.BaseName
                    SuccessCount = $ADSchemaExtJson.success_string_match_count
                    Content      = $ADSchemaExtContent
                    Variables    = $Variables
                    SchemaMaster = $SchemaMaster 
                }
                if ($ExecutionType -eq 'Remote') {
                    $ExtendDryADSchemaParams += @{
                        PSSession = $PSSession
                    }
                }
                
                ol i 'Extending AD Schema, type', "$($ADSchemaExtension.BaseName)"
                Set-DryADSchemaExtension @ExtendDryADSchemaParams
            }

            $DebugCounter = $NumberOfADSchemaExtensions
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessSchema)



        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   NETLOGON
        #   Action: Configure 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessNETLOGON) {  
            ol i "NETLOGON File Copy" -sh
            # increment the element counter and update progress
            $ElementsCounter++
            $WriteProgressParameters = @{
                Activity        = 'Configuring Active Directory'
                Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): NETLOGON"
                PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
            }
            Write-Progress @WriteProgressParameters
            $NETLOGONSourcePath = Join-Path -Path $ConfigurationPath -ChildPath 'netlogon'
            switch ($ExecutionType) {
                'Local' {
                    $NETLOGONTargetPath = "\\$DomainFQDN\NETLOGON\"
                }
                'Remote' {
                    $NETLOGONTargetPath = "C:\Windows\SYSVOL\domain\scripts\"
                }
            }
            ol i "NETLOGON source path", "$NETLOGONSourcePath\*"
            ol i "NETLOGON target path", "$NETLOGONTargetPath"

            $CopyNETLOGONParams = @{
                Path        = "$NETLOGONSourcePath\*"
                Destination = "$NETLOGONTargetPath" 
                Recurse     = $True 
                Force       = $True
                ErrorAction = 'Stop'
            }
            if ($ExecutionType -eq 'Remote') {
                $CopyNETLOGONParams += @{
                    ToSession = $PSSession        
                }
            }
            
            Copy-Item @CopyNETLOGONParams
        
            $DebugCounter += $NumberOfNETLOGONs
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   adm_templates
        #   Action: Configure 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessAdmTemplates) {  
            ol i "adm_templates File Copy" -sh
            # increment the element counter and update progress
            $ElementsCounter++
            $WriteProgressParameters = @{
                Activity        = 'Configuring Active Directory'
                Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Administrative Templates"
                PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
            }
            Write-Progress @WriteProgressParameters
            
            $AdmTemplatesSourcePath = "$ConfigurationPath\adm_templates\*"
            switch ($ExecutionType) { 
                'Local' {
                    $AdmTemplatesTargetPath = "\\\\$DomainFQDN\\SYSVOL\\$DomainFQDN\\Policies\\PolicyDefinitions\\"
                }
                'Remote' {
                    $AdmTemplatesTargetPath = "C:\\Windows\\SYSVOL\\domain\\Policies\\PolicyDefinitions\\"
                }
            }

            ol i "adm_templates source path", $AdmTemplatesSourcePath
            ol i "adm_templates target path", $AdmTemplatesTargetPath

            $CopyDryFilesToRemoteTargetParams = @{
                SourcePath = "$AdmTemplatesSourcePath" 
                TargetPath = "$AdmTemplatesTargetPath" 
            }
            
            if ($PSSession) {
                $CopyDryFilesToRemoteTargetParams += @{
                    PSSession = $PSSession
                }   
            }
            Copy-DryADFilesToRemoteTarget @CopyDryFilesToRemoteTargetParams | 
                Out-Null
        
            $DebugCounter += 1
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessOUs) {

            ol i "OUs - Domain scope ($($DomainOUs.count))" -sh
            foreach ($OU in $DomainOUs) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Creating OU: $($OU.Path)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
    
                # Create instance of class OU and invoke method CreateOU()
                ol i "Creating OU (domain '$DomainFQDN')", "$($OU.path)"
                
                switch ($ExecutionType) {
                    'Local' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $DomainController)
                    }
                    'Remote' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $PSSession)
                    }
                }
                $OUObject.CreateOU()
                
                Remove-Variable -Name OUObject -ErrorAction Ignore            
            }
            
            # loop through site OUs
            ol i "OUs - Site scope ($($SiteOUs.count))" -sh
            foreach ($OU in $SiteOUs) { 
                
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Creating OU: $($OU.Path)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                ol i "Creating OU (site '$adsite')", "$($OU.Path)"
                switch ($ExecutionType) {
                    'Local' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $DomainController)
                    }
                    'Remote' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $PSSession)
                    }
                }
                $OUObject.CreateOU()
                
                # clean up
                Remove-Variable -Name CopyOU -ErrorAction Ignore
            }

            # loop through site OUs
            ol i "OUs - Computer scope ($($ComputerOUs.count))" -sh
            foreach ($OU in $ComputerOUs) { 
                
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Creating OU: $($OU.Path)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                ol i "Creating OU (computer '$ComputerName')", "$($OU.Path)"
                switch ($ExecutionType) {
                    'Local' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $DomainController)
                    }
                    'Remote' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $PSSession)
                    }
                }
                $OUObject.CreateOU()
                
                # clean up
                Remove-Variable -Name CopyOU -ErrorAction Ignore
            }

            $DebugCounter += $NumberOfOUs
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }

        } # if ($ProcessOU)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   WMI FILTERS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessWMIFilterImports) {
            # WMIfilters. Log some info, then loop through each
            ol i "WMIFilters - Domain scope ($($DomainWMIfilters.count))" -sh

            # Make sure 'Allow System Only Change' in registry on domain controller is 1
            # If it isn't, WMIFilter creation will fail with access denied
            ol d "Calling 'Set-DryADRemoteRegistry' to set 'Allow System Only Change' to 1"
            
            $AllowSystemOnlyChangeParameters = @{
                BaseKey     = 'HKEY_LOCAL_MACHINE' 
                LeafKey     = 'System\\CurrentControlSet\\Services\\NTDS\\Parameters' 
                ValueName   = 'Allow System Only Change' 
                ValueData   = 1 
                ValueType   = 'DWORD'
                PSSession   = $PSSession
                ErrorAction = 'Stop'
            }
            
            Set-DryADRemoteRegistry @AllowSystemOnlyChangeParameters
            
            # $DomainWMIfilters
            foreach ($GPOWMIFilter in $DomainWMIfilters) {
                
                # Progress
                $ElementsCounter++  
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing WMIFilter '$($GPOWMIFilter.Name)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                }
                Write-Progress @WriteProgressParameters
            
                # Any GPMC command must run in a remote session, since the cmdlets lack the -credentials parameter
                $NewDryWmiFilterParameters = @{
                    Name        = $GPOWMIFilter.Name 
                    Description = $GPOWMIFilter.Description 
                    Query       = [Array]$GPOWMIFilter.Queries 
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryWmiFilterParameters += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryWmiFilterParameters += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Importing WMI Filter (domain '$DomainFQDN')", "$($GPOWMIFilter.Name)"
                New-DryADWmiFilter @NewDryWmiFilterParameters
            }

            # $SiteWMIfilters
            ol i "WMIFilters - Site scope ($($SiteWMIfilters.count))" -sh
            
            foreach ($GPOWMIFilter in $SiteWMIfilters) {
                # Progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing WMIFilter '$($GPOWMIFilter.Name)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                }
                Write-Progress @WriteProgressParameters
            
                # Any GPMC command must run in a remote session, since the cmdlets lack the -credentials parameter
                $NewDryWmiFilterParameters = @{
                    Name        = $GPOWMIFilter.Name 
                    Description = $GPOWMIFilter.Description 
                    Query       = [Array]$GPOWMIFilter.Queries 
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryWmiFilterParameters += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryWmiFilterParameters += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Importing WMI Filter (site '$adsite')", "$($GPOWMIFilter.Name)"
                New-DryADWmiFilter @NewDryWmiFilterParameters
            }

            # $ComputerWMIfilters
            ol i "WMIFilters - Computer scope ($($ComputerWMIfilters.count))" -sh
            
            foreach ($GPOWMIFilter in $ComputerWMIfilters) {
                # Progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing WMIFilter '$($GPOWMIFilter.Name)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                }
                Write-Progress @WriteProgressParameters
            
                $NewDryWmiFilterParameters = @{
                    Name        = $GPOWMIFilter.Name 
                    Description = $GPOWMIFilter.Description 
                    Query       = [Array]$GPOWMIFilter.Queries
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryWmiFilterParameters += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryWmiFilterParameters += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Importing WMI Filter (computer '$ComputerName')", "$($GPOWMIFilter.Name)"
                New-DryADWmiFilter @NewDryWmiFilterParameters
            }

            $DebugCounter += $NumberOfWMIFilters
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   RIGHTS GROUPS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessRightsGroups) {
            ol i "Rights Groups - Domain scope ($($DomainRightsGroups.count))" -sh
 
            # loop through domain Rights
            foreach ($RightsGroup in $DomainRightsGroups) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Rights Group: $($RightsGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   

                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RightsGroup.groupname
                    Path        = $RightsGroup.path
                    Description = $RightsGroup.groupdescription
                    Type        = $RightsGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Rights Group (domain '$DomainFQDN')", "$($RightsGroup.groupname)" 
                New-DryADSecurityGroup @NewDryADSecurityGroupParams
            }

            # loop through site Rights
            ol i "Rights Groups - Site scope ($($SiteRightsGroups.count))" -sh
        
            foreach ($RightsGroup in $SiteRightsGroups) { 
                
                # Add site to the description
                $RightsGroup.groupdescription = $RightsGroup.groupdescription + " (site '$adsite')"

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Rights Group: $($RightsGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RightsGroup.groupname
                    Path        = $RightsGroup.path
                    Description = $RightsGroup.groupdescription
                    Type        = $RightsGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Rights Group (site '$adsite')", "$($RightsGroup.groupname)"
                New-DryADSecurityGroup @NewDryADSecurityGroupParams   
            }

            # loop through site Rights
            ol i "Rights Groups - Computer scope ($($ComputerRightsGroups.count))" -sh
        
            foreach ($RightsGroup in $ComputerRightsGroups) { 
                
                # Add site to the description
                $RightsGroup.groupdescription = $RightsGroup.groupdescription + " (computer '$ComputerName')"

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Rights Group: $($RightsGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RightsGroup.groupname
                    Path        = $RightsGroup.path
                    Description = $RightsGroup.groupdescription
                    Type        = $RightsGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Rights Group (computer '$ComputerName')", "$($RightsGroup.groupname)"
                New-DryADSecurityGroup @NewDryADSecurityGroupParams   
            }

            $DebugCounter += $NumberOfRightsGroups
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessRightsGroups)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ROLE GROUPS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessRoleGroups) {
            ol i "Role Groups - Domain scope ($($DomainRoleGroups.count))" -sh
 
            # loop through domain Role  Groups
            foreach ($RoleGroup in $DomainRoleGroups) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Role Group: $($RoleGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   

                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RoleGroup.groupname
                    Path        = $RoleGroup.path
                    Description = $RoleGroup.groupdescription
                    Type        = $RoleGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Role Group (domain '$DomainFQDN')", "$($RoleGroup.groupname)" 
                New-DryADSecurityGroup @NewDryADSecurityGroupParams
            }

            # loop through site Role Groups
            ol i "Role Groups - Site scope ($($SiteRoleGroups.count))" -sh

            foreach ($RoleGroup in $SiteRoleGroups) { 
                
                # Add site to the description
                $RoleGroup.groupdescription = $RoleGroup.groupdescription + " (site '$adsite')"

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Role Group: $($RoleGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RoleGroup.groupname
                    Path        = $RoleGroup.path
                    Description = $RoleGroup.groupdescription
                    Type        = $RoleGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Role Group (site '$adsite')", "$($RoleGroup.groupname)"
                New-DryADSecurityGroup @NewDryADSecurityGroupParams   
            }

            # loop through site Role Groups
            ol i "Role Groups - Computer scope ($($ComputerRoleGroups.count))" -sh

            foreach ($RoleGroup in $ComputerRoleGroups) { 
                
                # Add computername to the description
                $RoleGroup.groupdescription = $RoleGroup.groupdescription + " (computer '$ComputerName')"

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Role Group: $($RoleGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RoleGroup.groupname
                    Path        = $RoleGroup.path
                    Description = $RoleGroup.groupdescription
                    Type        = $RoleGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Role Group (computer '$ComputerName')", "$($RoleGroup.groupname)"
                New-DryADSecurityGroup @NewDryADSecurityGroupParams   
            }

            $DebugCounter += $NumberOfRoleGroups
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
                 
        } # if ($ProcessRoleGroups)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP'S GROUP MEMBERS 
        #   Action: Add Role Groups to RightsGroups
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessGroupMembers) {
            ol i "Group Members - Domain scope ($NumberOfDomainMemberAndMemberOf)" -sh
            
            # Both Role and Rights groups may have .member and .memberof 
            foreach ($DomainRoleGroup in $DomainRoleGroups) {
                foreach ($DomainRoleGroupMember in $DomainRoleGroup.Member) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($DomainRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add Members to $DomainRoleGroup
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRoleGroup.groupname
                        Member = $DomainRoleGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (domain '$DomainFQDN')", "Adding '$DomainRoleGroupMember' to '$($DomainRoleGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($DomainRoleGroupMemberOf in $DomainRoleGroup.MemberOf) {
                    
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($DomainRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $DomainRoleGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRoleGroupMemberOf
                        Member = $DomainRoleGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (domain '$DomainFQDN')", "Adding '$($DomainRoleGroup.groupname)' to '$DomainRoleGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }


            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                foreach ($DomainRightsGroupMember in $DomainRightsGroup.Member) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($DomainRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add Members to $DomainRightsGroup
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRightsGroup.groupname
                        Member = $DomainRightsGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (domain '$DomainFQDN')", "Adding '$DomainRightsGroupMember' to '$($DomainRightsGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($DomainRightsGroupMemberOf in $DomainRightsGroup.MemberOf) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($DomainRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $DomainRightsGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRightsGroupMemberOf
                        Member = $DomainRightsGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (domain '$DomainFQDN')", "Adding '$($DomainRightsGroup.groupname)' to '$DomainRightsGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }

            ol i "Group Members - Site scope ($NumberOfSiteMemberAndMemberOf)" -sh
            
            foreach ($SiteRoleGroup in $SiteRoleGroups) {
                foreach ($SiteRoleGroupMember in $SiteRoleGroup.Member) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($SiteRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add Members to $SiteRoleGroup
                    $AddDryADGroupMemberParams = @{
                        Group  = $SiteRoleGroup.groupname
                        Member = $SiteRoleGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (site '$adsite')", "Adding '$SiteRoleGroupMember' to '$($SiteRoleGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($SiteRoleGroupMemberOf in $SiteRoleGroup.MemberOf) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($SiteRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $SiteRoleGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $SiteRoleGroupMemberOf
                        Member = $SiteRoleGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (site '$adsite')", "Adding '$($SiteRoleGroup.groupname)' to '$SiteRoleGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }

            foreach ($SiteRightsGroup in $SiteRightsGroups) { 
                foreach ($SiteRightsGroupMember in $SiteRightsGroup.Member) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($SiteRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add Members to $SiteRightsGroup
                    $AddDryADGroupMemberParams = @{
                        Group  = $SiteRightsGroup.groupname
                        Member = $SiteRightsGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (site '$adsite')", "Add '$SiteRightsGroupMember' to '$($SiteRightsGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($SiteRightsGroupMemberOf in $SiteRightsGroup.MemberOf) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($SiteRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $SiteRightsGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $SiteRightsGroupMemberOf
                        Member = $SiteRightsGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (site '$adsite')", "Add '$($SiteRightsGroup.groupname)' to '$SiteRightsGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }

            ol i "Group Members - Computer scope ($NumberOfComputerMemberAndMemberOf)" -sh
            foreach ($ComputerRoleGroup in $ComputerRoleGroups) {
                foreach ($ComputerRoleGroupMember in $ComputerRoleGroup.Member) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($ComputerRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add Members to $ComputerRoleGroup
                    $AddDryADGroupMemberParams = @{
                        Group  = $ComputerRoleGroup.groupname
                        Member = $ComputerRoleGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (Computer '$ComputerName')", "Add '$ComputerRoleGroupMember' to '$($ComputerRoleGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($ComputerRoleGroupMemberOf in $ComputerRoleGroup.MemberOf) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($ComputerRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $ComputerRoleGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $ComputerRoleGroupMemberOf
                        Member = $ComputerRoleGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (Computer '$ComputerName')", "Add '$($ComputerRoleGroup.groupname)' to '$ComputerRoleGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }

            foreach ($ComputerRightsGroup in $ComputerRightsGroups) {  
                foreach ($ComputerRightsGroupMember in $ComputerRightsGroup.Member) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($ComputerRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add Members to $ComputerRightsGroup
                    $AddDryADGroupMemberParams = @{
                        Group  = $ComputerRightsGroup.groupname
                        Member = $ComputerRightsGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (Computer '$ComputerName'): Add '$ComputerRightsGroupMember' to '$($ComputerRightsGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($ComputerRightsGroupMemberOf in $ComputerRightsGroup.MemberOf) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($ComputerRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $ComputerRightsGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $ComputerRightsGroupMemberOf
                        Member = $ComputerRightsGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (Computer '$CompterName')", "Add '$($ComputerRightsGroup.groupname)' to '$ComputerRightsGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }

            $DebugCounter += $NumberOfMemberAndMemberOf
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USERS 
        #   Action: Getting the connection point's public certificate. 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessUsers) {
            if (
                ($NumberOfUsers.Count -gt 0) -and 
                ($ExecutionType -eq 'Remote')
            ) {
                ol i "Users - Getting the Connection Point's public certificate" -sh
                try {
                    Get-DryADRemotePublicCertificate -PSSession $PSSession -CertificateFile $ConfigurationPublicCertificatePath
                }
                catch {
                    $PSCmdLet.ThrowTerminatingError($_)
                }
            }
            

            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
            # 
            #   USERS 
            #   Action: Create
            #
            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
            ol i "Users - Domain scope ($($DomainUsers.count))" -sh
 
            # loop through domain Users
            foreach ($User in $DomainUsers) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): User: $($User.name)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   

                }
                Write-Progress @WriteProgressParameters

                $NewDryADUserParams = @{
                    User      = $User
                    DomainNB  = $DomainNB
                    DryDeploy = $DryDeploy
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADUserParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADUserParams += @{
                            PSSession                   = $PSSession
                            DCPublicCertificateFilePath = $ConfigurationPublicCertificatePath
                        }
                    }
                }
                ol i "Creating User (domain '$DomainFQDN')", "$($User.name)" 
                New-DryADUser @NewDryADUserParams
            }

            # loop through site Users
            ol i "Users - Site scope ($($SiteUsers.count))" -sh
        
            foreach ($User in $SiteUsers) { 

                # Add site to the description
                $User.description = $User.description + " (site '$adsite')"

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): User: $($User.name)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $NewDryADUserParams = @{
                    User      = $User
                    DomainNB  = $DomainNB
                    DryDeploy = $DryDeploy
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADUserParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADUserParams += @{
                            PSSession                   = $PSSession
                            DCPublicCertificateFilePath = $ConfigurationPublicCertificatePath
                        }
                    }
                }
                ol i "Creating User (site '$adsite')", "$($User.name)"
                New-DryADUser @NewDryADUserParams
            }

            # loop through site Users
            ol i "Users - Computer scope ($($ComputerUsers.count))" -sh
        
            foreach ($User in $ComputerUsers) { 
                
                # Add site to the description
                $User.description = $User.description + " (computer '$ComputerName')"

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): User: $($User.name)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $NewDryADUserParams = @{
                    User      = $User
                    DomainNB  = $DomainNB
                    DryDeploy = $DryDeploy
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADUserParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADUserParams += @{
                            PSSession                   = $PSSession
                            DCPublicCertificateFilePath = $ConfigurationPublicCertificatePath
                        }
                    }
                }
                ol i "Creating User (computer '$ComputerName')", "$($User.name)"
                New-DryADUser @NewDryADUserParams
            }

            $DebugCounter += $NumberOfUsers
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessUsers)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USER'S GROUP MEMBERSHIPS 
        #   Action: Add Users to Groups
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessUserMemberOf) {
            ol i "User Group Memberships Domain scope ($NumberOfDomainUserMemberOf)" -sh
            
            # Both Role and Rights groups may have .member and .memberof 
            foreach ($DomainUser in $DomainUsers) {
                foreach ($DomainUserMemberOf in $DomainUser.MemberOf) {
                    
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): $($DomainUser.name) member of: $DomainUserMemberOf"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
        
                    # Add $DomainUser to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainUserMemberOf
                        Member = $DomainUser.name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (domain '$DomainFQDN')", "Adding '$($DomainUser.name)' to '$DomainUserMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }
        
            ol i "User Group Memberships Site scope ($NumberOfSiteUserMemberOf)" -sh
            
            foreach ($SiteUser in $SiteUsers) {
                foreach ($SiteUserMemberOf in $SiteUser.MemberOf) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): $($SiteUser.name) member of: $SiteUserMemberOf"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
        
                    # Add $SiteUser to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $SiteUserMemberOf
                        Member = $SiteUser.name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (site '$adsite')", "Adding '$($SiteUser.name)' to '$SiteUserMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }
        
            ol i "User Group Memberships Computer scope ($NumberOfComputerUserMemberOf)" -sh
            foreach ($ComputerUser in $ComputerUsers) {
                foreach ($ComputerUserMemberOf in $ComputerUser.MemberOf) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess):  $($ComputerUser.name) member of: $ComputerUserMemberOf"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
        
                    # Add $ComputerUser to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $ComputerUserMemberOf
                        Member = $ComputerUser.name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members (computer '$ComputerName')", "Add '$($ComputerUser.name)' to '$ComputerUserMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }
        
            $DebugCounter += $NumberOfUserMemberOf
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ACTIVE DIRECTORY RIGHTS 
        #   Action: Delegate Rights in AD
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
        if ($ProcessRights) {
            ol i "Rights - Domain scope ($NumberOfDomainRights)" -sh

            # Domain Rights
            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                foreach ($DomainRight in $DomainRightsGroup.Rights) {
                    ol v "Setting rights for group '$($DomainRightsGroup.groupname)'"
                    
                    # create hash from properties of the object 
                    Remove-Variable -Name SetDryADAccessRuleParams -ErrorAction Ignore
                    $SetDryADAccessRuleParams = @{}
                    
                    # Add all properties but site and scope to the rights hash
                    $DomainRight.PSObject.Properties | ForEach-Object {
                        if ($_.Name -notin @('scope')) {
                            $SetDryADAccessRuleParams.Add($_.Name, $_.Value)
                        }
                    }

                    # Add the groupname as 'Group' - the owner of the right
                    $SetDryADAccessRuleParams.Add('Group', $DomainRightsGroup.groupname)

                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryADAccessRuleParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryADAccessRuleParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }

                    # Debug logging
                    ol d -hash $SetDryADAccessRuleParams

                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Domain Right: $($DomainRight.Path)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
                    
                    # Set the right
                    ol i "Rights (domain '$DomainFQDN')", "Group '$($DomainRightsGroup.groupname)'"
                    ol i "Rights (domain '$DomainFQDN')", "Target '$($DomainRight.Path)'"
                    if ((Set-DryADAccessRule @SetDryADAccessRuleParams) -eq $True) {
                        ol i "Rights (domain '$DomainFQDN')", ''
                    } 
                    else {
                        ol e @("Rights (domain '$DomainFQDN')", "Group '$($DomainRightsGroup.groupname)', Target '$($DomainRight.Path)'")
                        throw "Failed: domain '$DomainFQDN'): Group '$($DomainRightsGroup.groupname)', Target '$($DomainRight.Path)'"
                    }

                    # Clean up
                    Remove-Variable -Name SetDryADAccessRuleParams, WriteProgressParameters -ErrorAction Ignore   
                }
            }

            # Site Rights
            ol i "Rights - Site scope ($NumberOfSiteRights)" -sh
            foreach ($SiteRightsGroup in $SiteRightsGroups) {
                foreach ($SiteRight in $SiteRightsGroup.Rights) {

                    # create hash from properties of the object 
                    Remove-Variable -Name SetDryADAccessRuleParams -ErrorAction Ignore
                    $SetDryADAccessRuleParams = @{}
                    
                    # Add all properties but site and scope to the rights hash
                    $SiteRight.PSObject.Properties | ForEach-Object {
                        if ($_.Name -notin @('scope')) {
                            $SetDryADAccessRuleParams.Add($_.Name, $_.Value)
                        }
                    }

                    # Add the groupname as 'Group' - the owner of the right
                    $SetDryADAccessRuleParams.Add('Group', $SiteRightsGroup.groupname)

                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryADAccessRuleParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryADAccessRuleParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    
                    # Debug logging
                    ol d -hash $SetDryADAccessRuleParams 

                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Site Right: $($SiteRight.Path)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
                    
                    # Set the right
                    ol i "Rights (site '$adsite')", "Group '$($SiteRightsGroup.groupname)'"
                    ol i "Rights (site '$adsite')", "Target '$($SiteRight.Path)'"
                    if ((Set-DryADAccessRule @SetDryADAccessRuleParams) -eq $True) {
                        ol i "Rights (site '$adsite')", ''
                    }
                    else {
                        ol e @("Rights (site '$adsite')", "Group '$($SiteRightsGroup.groupname)', Target '$($SiteRight.Path)'")
                        throw "Failed: Rights (site '$adsite'): Group '$($SiteRightsGroup.groupname)', Target '$($SiteRight.Path)'"
                    }

                    # Clean up
                    Remove-Variable -Name SetDryADAccessRuleParams, WriteProgressParameters -ErrorAction Ignore
                }
            }

            # Computer scoped Rights
            ol i "Rights - Computer scope ($NumberOfComputerRights)" -sh
            foreach ($ComputerRightsGroup in $ComputerRightsGroups) {
                foreach ($ComputerRight in $ComputerRightsGroup.Rights) {

                    # create hash from properties of the object 
                    Remove-Variable -Name SetDryADAccessRuleParams -ErrorAction Ignore
                    $SetDryADAccessRuleParams = @{}
                    
                    # Add all properties but site and scope to the rights hash
                    $ComputerRight.PSObject.Properties | ForEach-Object {
                        if ($_.Name -notin @('scope')) {
                            $SetDryADAccessRuleParams.Add($_.Name, $_.Value)
                        }
                    }

                    # Add the groupname as 'Group' - the owner of the right
                    $SetDryADAccessRuleParams.Add('Group', $ComputerRightsGroup.groupname)

                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryADAccessRuleParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryADAccessRuleParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    
                    # Debug logging
                    ol d -hash $SetDryADAccessRuleParams 

                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Computer Right: $($ComputerRight.Path)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
                    
                    # Set the right
                    ol i "Rights (Computer '$ComputerName')", "Group '$($ComputerRightsGroup.groupname)' =>"
                    ol i "Rights (Computer '$ComputerName')", "Target '$($ComputerRight.Path)'"
                    if ((Set-DryADAccessRule @SetDryADAccessRuleParams) -eq $True) {
                        ol i "Rights (Computer '$ComputerName')", ''
                    } 
                    else {
                        ol e @("Rights (Computer '$ComputerName')", "Group '$($ComputerRightsGroup.groupname)', Target '$($ComputerRight.Path)'")
                        throw "Failed: Rights (Computer '$ComputerName')", "Group '$($ComputerRightsGroup.groupname)', Target '$($ComputerRight.Path)'"
                    }

                    # Clean up
                    Remove-Variable -Name SetDryADAccessRuleParams, WriteProgressParameters -ErrorAction Ignore
                }
            }
            
            $DebugCounter += $NumberOfRights
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICIES 
        #   Action: Define paths, copy helper modules and GPOs to remote target if
        #   ExecutionType 'Remote'
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessGPOImports) {
            switch ($ExecutionType) {
                'Remote' {
                    [String]$RemoteRootPath = "C:\DryDeploy\"
                    [String]$GPOsPath = Join-Path -Path $RemoteRootPath -ChildPath 'gpo_imports'

                    # Only invoke if json-gpos in configuration
                    if ($RequiresGPOHelper) {
                        ol i "GPO Imports - Copying helper module to remote target" -sh
                        $DryADGPOHelpersPath = Join-Path -Path (Get-Module -Name dry.module.ad).Path -ChildPath 'helpers\dry.ad.gpohelper' 
                        Copy-DryADModulesToRemoteTarget -PSSession $PSSession -RemoteRootPath $RemoteRootPath -Folders @("$DryADGPOHelpersPath") -Force | Out-Null
                        Copy-DryADModulesToRemoteTarget -PSSession $PSSession -RemoteRootPath $RemoteRootPath -Modules @("GPRegistryPolicyParser") | Out-Null
                    }

                    ol i "GPO Imports - Copying GPOs to remote target" -sh
                    Copy-DryADFilesToRemoteTarget -PSSession $PSSession -TargetPath $RemoteRootPath -SourcePath $SourceGPOsPath | Out-Null
                }
                'Local' {
                    [String]$GPOsPath = $SourceGPOsPath
                }
            }  

            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
            # 
            #   GROUP POLICIES 
            #   Action: Import
            #
            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

            ol i "GPO Imports - Domain scope ($($DomainGPOImports.count))" -sh
            foreach ($GPO in $DomainGPOImports) {
                # Ensure TargetName exists, and is converted to the desired case
                if ($Null -eq $GPO.TargetName) { 
                    $GPO | 
                        Add-Member -MemberType NoteProperty -Name 'TargetName' -Value $(ConvertTo-DryADCase -Name $GPO.Name -Case $GPOcase)
                }
                else {
                    $GPO.TargetName = ConvertTo-DryADCase -Name $GPO.TargetName -Case $GPOcase
                }

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing GPO '$($GPO.TargetName)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                $ImportDryADGPOParams = @{
                    GPO             = $GPO 
                    GPOsPath        = $GPOsPath 
                    Scope           = 'domain'
                    ReplacementHash = $ReplacementHash
                }

                switch ($ExecutionType) {
                    'Local' {
                        $ImportDryADGPOParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $ImportDryADGPOParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "GPO Import (domain '$DomainFQDN')", "Importing '$($GPO.Name)'"
                Import-DryADGPO @ImportDryADGPOParams      
            }

            ol i "GPO Imports - Site scope ($($SiteGPOImports.count))" -sh
            foreach ($GPO in $SiteGPOImports) {
                # Ensure TargetName exists, and is converted to the desired case
                if ($Null -eq $GPO.TargetName) { 
                    $GPO | 
                        Add-Member -MemberType NoteProperty -Name 'TargetName' -Value $(ConvertTo-DryADCase -Name $GPO.Name -Case $GPOcase)
                }
                else {
                    $GPO.TargetName = ConvertTo-DryADCase -Name $GPO.TargetName -Case $GPOcase
                }
                
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing GPO '$($GPO.Name)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $ImportDryADGPOParams = @{
                    GPO             = $GPO 
                    GPOsPath        = $GPOsPath 
                    Scope           = 'site'
                    ReplacementHash = $ReplacementHash
                }
                switch ($ExecutionType) {
                    'Local' {
                        $ImportDryADGPOParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $ImportDryADGPOParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "GPO Import (site '$ADSite')", "Importing '$($GPO.Name)'"
                Import-DryADGPO @ImportDryADGPOParams
            }

            ol i "GPO Imports - Computer scope ($($ComputerGPOImports.count))" -sh
            foreach ($GPO in $ComputerGPOImports) {
                # Ensure TargetName exists, and is converted to the desired case
                if ($Null -eq $GPO.TargetName) { 
                    $GPO | 
                        Add-Member -MemberType NoteProperty -Name 'TargetName' -Value $(ConvertTo-DryADCase -Name $GPO.Name -Case $GPOcase)
                }
                else {
                    $GPO.TargetName = ConvertTo-DryADCase -Name $GPO.TargetName -Case $GPOcase
                }
                
                # Increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing GPO '$($GPO.Name)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters

                $ImportDryADGPOParams = @{
                    GPO             = $GPO 
                    GPOsPath        = $GPOsPath 
                    Scope           = 'computer'
                    ReplacementHash = $ReplacementHash
                }
                switch ($ExecutionType) {
                    'Local' {
                        $ImportDryADGPOParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $ImportDryADGPOParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                ol i "GPO Import (Computer '$ComputerName')", "Importing '$($GPO.Name)'"
                Import-DryADGPO @ImportDryADGPOParams     
            }

            $DebugCounter += $NumberOfGPOImports
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }

        } # if ($ProcessGPO)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICIES 
        #   Action: Links
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessGPOLinks) {
            ol i "GPO Links - Domain scope ($($DomainGPOLinks.count))" -sh

            foreach ($DomainGPOLink in $DomainGPOLinks | Where-Object { $_.defined_in -eq 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($DomainGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                 
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $DomainGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }

                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                if (($DomainGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs (domain '$DomainFQDN') to", "(Domain Root)"
                } 
                else {
                    ol i "Link GPOs (domain '$DomainFQDN') to", "$($DomainGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }

            foreach ($DomainGPOLink in $DomainGPOLinks | Where-Object { $_.defined_in -ne 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($DomainGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                 
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $DomainGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }
                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                if (($DomainGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs (domain '$DomainFQDN') to", "(Domain Root)"
                } 
                else {
                    ol i "Link GPOs (domain '$DomainFQDN') to", "$($DomainGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }

           
            ol i "GPO Links - Site scope ($($SiteGPOLinks.count))" -sh
            
            # loop through Site GPOLinks defined by the OS Config
            foreach ($SiteGPOLink in $SiteGPOLinks | Where-Object { $_.defined_in -eq 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($SiteGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $SiteGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }

                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                if (($SiteGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs (site '$adsite') to", "(Root of Domain)"
                } 
                else {
                    ol i "Link GPOs (site '$adsite') to", "$($SiteGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }

            # loop through Site GPOLinks defined by the Role
            foreach ($SiteGPOLink in $SiteGPOLinks | Where-Object { $_.defined_in -ne 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($SiteGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $SiteGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }

                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                if (($SiteGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs (site '$adsite') to", "(Root of Domain)"
                } 
                else {
                    ol i "Link GPOs (site '$adsite') to", "$($SiteGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }
            
            ol i "GPO Links - Computer scope ($($ComputerGPOLinks.count))" -sh
            
            # loop through Computer GPOLinks defined by the OS Config
            foreach ($ComputerGPOLink in $ComputerGPOLinks | Where-Object { $_.defined_in -eq 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($ComputerGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                 
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $ComputerGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }

                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                if (($ComputerGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs (Computer '$ComputerName') to", "(Root of Domain)"
                } 
                else {
                    ol i "Link GPOs (Computer '$ComputerName') to", "$($ComputerGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }

            # loop through Computer GPOLinks defined by the Role
            foreach ($ComputerGPOLink in $ComputerGPOLinks | Where-Object { $_.defined_in -ne 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($ComputerGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $ComputerGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }

                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                
                if (($ComputerGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs (Computer '$ComputerName') to", "(Root of Domain)"
                } 
                else {
                    ol i "Link GPOs (Computer '$ComputerName') to", "$($ComputerGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }

            $DebugCounter += $NumberOfGPOLinks
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessGPOLinks)
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   Wmi Filter Links 
        #   Action: Link to GPOs
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessWMIFilterLinks) {

            ol i "WMIFilterLinks - Domain scope ($DomainWmiFilterLinksCount)" -sh
            foreach ($GPOWMIFilter in $DomainWMIFilters) {
                foreach ($GPOWMIFilterLink in $GPOWMIFilter.links) {
                    # Progress
                    $ElementsCounter++  
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking WMIFilter '$($GPOWMIFilter.Name)'"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                    }
                    Write-Progress @WriteProgressParameters
                
                    $SetDryWmiFilterLinkParams = @{
                        GPOName       = $GPOWMIFilterLink
                        WMIFilterName = $GPOWMIFilter.Name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryWmiFilterLinkParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryWmiFilterLinkParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Linking WMI Filter (domain '$DomainFQDN')", "$($GPOWMIFilter.Name)"
                    Set-DryADWmiFilterLink @SetDryWmiFilterLinkParams
                }
            }

            ol i "WMIFilters - Site scope ($SiteWmiFilterLinksCount)" -sh
            foreach ($GPOWMIFilter in $SiteWMIFilters) {
                foreach ($GPOWMIFilterLink in $GPOWMIFilter.links) {
                    # Progress
                    $ElementsCounter++  
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking WMIFilter '$($GPOWMIFilter.Name)'"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                    }
                    Write-Progress @WriteProgressParameters
                
                    $SetDryWmiFilterLinkParams = @{
                        GPOName       = $GPOWMIFilterLink
                        WMIFilterName = $GPOWMIFilter.Name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryWmiFilterLinkParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryWmiFilterLinkParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Linking WMI Filter (site '$adsite')", "$($GPOWMIFilter.Name)"
                    Set-DryADWmiFilterLink @SetDryWmiFilterLinkParams
                }
            }

            ol i "WMIFilters - Computer scope ($ComputerWmiFilterLinksCount)" -sh
            foreach ($GPOWMIFilter in $ComputerWMIFilters) {
                foreach ($GPOWMIFilterLink in $GPOWMIFilter.links) {
                    # Progress
                    $ElementsCounter++  
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking WMIFilter '$($GPOWMIFilter.Name)'"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                    }
                    Write-Progress @WriteProgressParameters
                
                    $SetDryWmiFilterLinkParams = @{
                        GPOName       = $GPOWMIFilterLink
                        WMIFilterName = $GPOWMIFilter.Name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryWmiFilterLinkParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryWmiFilterLinkParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Linking WMI Filter (computer '$ComputerName')", "$($GPOWMIFilter.Name)"
                    Set-DryADWmiFilterLink @SetDryWmiFilterLinkParams
                }
            }

            $DebugCounter += $NumberOfWMIFilterLinks
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } 
        ol i "Import-DryADConfiguration ran successfully" -sh
    }
    catch {
        $PSCmdLet.ThrowTerminatingError($_)
    }
    finally {
        Write-Progress -Completed -Activity "Configuring AD objects"
    }
}
